/*
 * RingCentral Connect Platform API
 *
 * RingCentral Connect Platform API
 *
 * The version of the OpenAPI document: 1.0.48
 * Contact: platform@ringcentral.com
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

using System;
using System.Linq;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Runtime.Serialization;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using System.ComponentModel.DataAnnotations;
using OpenAPIDateConverter = Org.OpenAPITools.Client.OpenAPIDateConverter;

namespace Org.OpenAPITools.Model
{
    /// <summary>
    /// CompanyAnsweringRuleUpdate
    /// </summary>
    [DataContract]
    public partial class CompanyAnsweringRuleUpdate :  IEquatable<CompanyAnsweringRuleUpdate>, IValidatableObject
    {
        /// <summary>
        /// Specifies how incoming calls are forwarded. The default value is &#39;Operator&#39; &#39;Operator&#39; - play company greeting and forward to operator extension &#39;Disconnect&#39; - play company greeting and disconnect &#39;Bypass&#39; - bypass greeting to go to selected extension &#x3D; [&#39;Operator&#39;, &#39;Disconnect&#39;,&#39;Bypass&#39;]
        /// </summary>
        /// <value>Specifies how incoming calls are forwarded. The default value is &#39;Operator&#39; &#39;Operator&#39; - play company greeting and forward to operator extension &#39;Disconnect&#39; - play company greeting and disconnect &#39;Bypass&#39; - bypass greeting to go to selected extension &#x3D; [&#39;Operator&#39;, &#39;Disconnect&#39;,&#39;Bypass&#39;]</value>
        [JsonConverter(typeof(StringEnumConverter))]
        public enum CallHandlingActionEnum
        {
            /// <summary>
            /// Enum Operator for value: Operator
            /// </summary>
            [EnumMember(Value = "Operator")]
            Operator = 1,

            /// <summary>
            /// Enum Disconnect for value: Disconnect
            /// </summary>
            [EnumMember(Value = "Disconnect")]
            Disconnect = 2,

            /// <summary>
            /// Enum Bypass for value: Bypass
            /// </summary>
            [EnumMember(Value = "Bypass")]
            Bypass = 3

        }

        /// <summary>
        /// Specifies how incoming calls are forwarded. The default value is &#39;Operator&#39; &#39;Operator&#39; - play company greeting and forward to operator extension &#39;Disconnect&#39; - play company greeting and disconnect &#39;Bypass&#39; - bypass greeting to go to selected extension &#x3D; [&#39;Operator&#39;, &#39;Disconnect&#39;,&#39;Bypass&#39;]
        /// </summary>
        /// <value>Specifies how incoming calls are forwarded. The default value is &#39;Operator&#39; &#39;Operator&#39; - play company greeting and forward to operator extension &#39;Disconnect&#39; - play company greeting and disconnect &#39;Bypass&#39; - bypass greeting to go to selected extension &#x3D; [&#39;Operator&#39;, &#39;Disconnect&#39;,&#39;Bypass&#39;]</value>
        [DataMember(Name="callHandlingAction", EmitDefaultValue=false)]
        public CallHandlingActionEnum? CallHandlingAction { get; set; }
        /// <summary>
        /// Type of an answering rule
        /// </summary>
        /// <value>Type of an answering rule</value>
        [JsonConverter(typeof(StringEnumConverter))]
        public enum TypeEnum
        {
            /// <summary>
            /// Enum BusinessHours for value: BusinessHours
            /// </summary>
            [EnumMember(Value = "BusinessHours")]
            BusinessHours = 1,

            /// <summary>
            /// Enum AfterHours for value: AfterHours
            /// </summary>
            [EnumMember(Value = "AfterHours")]
            AfterHours = 2,

            /// <summary>
            /// Enum Custom for value: Custom
            /// </summary>
            [EnumMember(Value = "Custom")]
            Custom = 3

        }

        /// <summary>
        /// Type of an answering rule
        /// </summary>
        /// <value>Type of an answering rule</value>
        [DataMember(Name="type", EmitDefaultValue=false)]
        public TypeEnum? Type { get; set; }
        /// <summary>
        /// Initializes a new instance of the <see cref="CompanyAnsweringRuleUpdate" /> class.
        /// </summary>
        /// <param name="enabled">Specifies if the rule is active or inactive. The default value is &#39;True&#39; (default to true).</param>
        /// <param name="name">Name of an answering rule specified by user. Max number of symbols is 30. The default value is &#39;My Rule N&#39; where &#39;N&#39; is the first free number.</param>
        /// <param name="callers">Answering rule will be applied when calls are received from the specified caller(s).</param>
        /// <param name="calledNumbers">Answering rule will be applied when calling the specified number(s).</param>
        /// <param name="schedule">schedule.</param>
        /// <param name="callHandlingAction">Specifies how incoming calls are forwarded. The default value is &#39;Operator&#39; &#39;Operator&#39; - play company greeting and forward to operator extension &#39;Disconnect&#39; - play company greeting and disconnect &#39;Bypass&#39; - bypass greeting to go to selected extension &#x3D; [&#39;Operator&#39;, &#39;Disconnect&#39;,&#39;Bypass&#39;].</param>
        /// <param name="type">Type of an answering rule (default to TypeEnum.Custom).</param>
        /// <param name="extension">Internal identifier of the extension the call is forwarded to. Supported for &#39;Bypass&#39; mode only (that should be specified in &#x60;callHandlingAction&#x60; field).</param>
        /// <param name="greetings">Greetings applied for an answering rule; only predefined greetings can be applied, see Dictionary Greeting List.</param>
        public CompanyAnsweringRuleUpdate(bool enabled = true, string name = default(string), List<CompanyAnsweringRuleCallersInfoRequest> callers = default(List<CompanyAnsweringRuleCallersInfoRequest>), List<CompanyAnsweringRuleCalledNumberInfo> calledNumbers = default(List<CompanyAnsweringRuleCalledNumberInfo>), CompanyAnsweringRuleScheduleInfoRequest schedule = default(CompanyAnsweringRuleScheduleInfoRequest), CallHandlingActionEnum? callHandlingAction = default(CallHandlingActionEnum?), TypeEnum? type = TypeEnum.Custom, string extension = default(string), List<GreetingInfo> greetings = default(List<GreetingInfo>))
        {
            // use default value if no "enabled" provided
            if (enabled == null)
            {
                this.Enabled = true;
            }
            else
            {
                this.Enabled = enabled;
            }
            this.Name = name;
            this.Callers = callers;
            this.CalledNumbers = calledNumbers;
            this.Schedule = schedule;
            this.CallHandlingAction = callHandlingAction;
            // use default value if no "type" provided
            if (type == null)
            {
                this.Type = TypeEnum.Custom;
            }
            else
            {
                this.Type = type;
            }
            this.Extension = extension;
            this.Greetings = greetings;
        }

        /// <summary>
        /// Specifies if the rule is active or inactive. The default value is &#39;True&#39;
        /// </summary>
        /// <value>Specifies if the rule is active or inactive. The default value is &#39;True&#39;</value>
        [DataMember(Name="enabled", EmitDefaultValue=false)]
        public bool Enabled { get; set; }

        /// <summary>
        /// Name of an answering rule specified by user. Max number of symbols is 30. The default value is &#39;My Rule N&#39; where &#39;N&#39; is the first free number
        /// </summary>
        /// <value>Name of an answering rule specified by user. Max number of symbols is 30. The default value is &#39;My Rule N&#39; where &#39;N&#39; is the first free number</value>
        [DataMember(Name="name", EmitDefaultValue=false)]
        public string Name { get; set; }

        /// <summary>
        /// Answering rule will be applied when calls are received from the specified caller(s)
        /// </summary>
        /// <value>Answering rule will be applied when calls are received from the specified caller(s)</value>
        [DataMember(Name="callers", EmitDefaultValue=false)]
        public List<CompanyAnsweringRuleCallersInfoRequest> Callers { get; set; }

        /// <summary>
        /// Answering rule will be applied when calling the specified number(s)
        /// </summary>
        /// <value>Answering rule will be applied when calling the specified number(s)</value>
        [DataMember(Name="calledNumbers", EmitDefaultValue=false)]
        public List<CompanyAnsweringRuleCalledNumberInfo> CalledNumbers { get; set; }

        /// <summary>
        /// Gets or Sets Schedule
        /// </summary>
        [DataMember(Name="schedule", EmitDefaultValue=false)]
        public CompanyAnsweringRuleScheduleInfoRequest Schedule { get; set; }



        /// <summary>
        /// Internal identifier of the extension the call is forwarded to. Supported for &#39;Bypass&#39; mode only (that should be specified in &#x60;callHandlingAction&#x60; field)
        /// </summary>
        /// <value>Internal identifier of the extension the call is forwarded to. Supported for &#39;Bypass&#39; mode only (that should be specified in &#x60;callHandlingAction&#x60; field)</value>
        [DataMember(Name="extension", EmitDefaultValue=false)]
        public string Extension { get; set; }

        /// <summary>
        /// Greetings applied for an answering rule; only predefined greetings can be applied, see Dictionary Greeting List
        /// </summary>
        /// <value>Greetings applied for an answering rule; only predefined greetings can be applied, see Dictionary Greeting List</value>
        [DataMember(Name="greetings", EmitDefaultValue=false)]
        public List<GreetingInfo> Greetings { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("class CompanyAnsweringRuleUpdate {\n");
            sb.Append("  Enabled: ").Append(Enabled).Append("\n");
            sb.Append("  Name: ").Append(Name).Append("\n");
            sb.Append("  Callers: ").Append(Callers).Append("\n");
            sb.Append("  CalledNumbers: ").Append(CalledNumbers).Append("\n");
            sb.Append("  Schedule: ").Append(Schedule).Append("\n");
            sb.Append("  CallHandlingAction: ").Append(CallHandlingAction).Append("\n");
            sb.Append("  Type: ").Append(Type).Append("\n");
            sb.Append("  Extension: ").Append(Extension).Append("\n");
            sb.Append("  Greetings: ").Append(Greetings).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as CompanyAnsweringRuleUpdate);
        }

        /// <summary>
        /// Returns true if CompanyAnsweringRuleUpdate instances are equal
        /// </summary>
        /// <param name="input">Instance of CompanyAnsweringRuleUpdate to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(CompanyAnsweringRuleUpdate input)
        {
            if (input == null)
                return false;

            return 
                (
                    this.Enabled == input.Enabled ||
                    (this.Enabled != null &&
                    this.Enabled.Equals(input.Enabled))
                ) && 
                (
                    this.Name == input.Name ||
                    (this.Name != null &&
                    this.Name.Equals(input.Name))
                ) && 
                (
                    this.Callers == input.Callers ||
                    this.Callers != null &&
                    input.Callers != null &&
                    this.Callers.SequenceEqual(input.Callers)
                ) && 
                (
                    this.CalledNumbers == input.CalledNumbers ||
                    this.CalledNumbers != null &&
                    input.CalledNumbers != null &&
                    this.CalledNumbers.SequenceEqual(input.CalledNumbers)
                ) && 
                (
                    this.Schedule == input.Schedule ||
                    (this.Schedule != null &&
                    this.Schedule.Equals(input.Schedule))
                ) && 
                (
                    this.CallHandlingAction == input.CallHandlingAction ||
                    (this.CallHandlingAction != null &&
                    this.CallHandlingAction.Equals(input.CallHandlingAction))
                ) && 
                (
                    this.Type == input.Type ||
                    (this.Type != null &&
                    this.Type.Equals(input.Type))
                ) && 
                (
                    this.Extension == input.Extension ||
                    (this.Extension != null &&
                    this.Extension.Equals(input.Extension))
                ) && 
                (
                    this.Greetings == input.Greetings ||
                    this.Greetings != null &&
                    input.Greetings != null &&
                    this.Greetings.SequenceEqual(input.Greetings)
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.Enabled != null)
                    hashCode = hashCode * 59 + this.Enabled.GetHashCode();
                if (this.Name != null)
                    hashCode = hashCode * 59 + this.Name.GetHashCode();
                if (this.Callers != null)
                    hashCode = hashCode * 59 + this.Callers.GetHashCode();
                if (this.CalledNumbers != null)
                    hashCode = hashCode * 59 + this.CalledNumbers.GetHashCode();
                if (this.Schedule != null)
                    hashCode = hashCode * 59 + this.Schedule.GetHashCode();
                if (this.CallHandlingAction != null)
                    hashCode = hashCode * 59 + this.CallHandlingAction.GetHashCode();
                if (this.Type != null)
                    hashCode = hashCode * 59 + this.Type.GetHashCode();
                if (this.Extension != null)
                    hashCode = hashCode * 59 + this.Extension.GetHashCode();
                if (this.Greetings != null)
                    hashCode = hashCode * 59 + this.Greetings.GetHashCode();
                return hashCode;
            }
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }

}
